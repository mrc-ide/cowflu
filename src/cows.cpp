// Generated by dust2 (version 0.1.0) - do not edit

#include <dust2/common.hpp>
#include <numeric>

// [[dust2::class(cows)]]
// [[dust2::time_type(discrete)]]
class cows {
public:
  cows() = delete;

  using real_type = double;

  struct shared_state {
    size_t n_herds;
    size_t n_regions;
    real_type gamma;
    real_type sigma;
    real_type beta;
    real_type alpha;
    real_type time_test;
    real_type n_test;
    std::vector<size_t> region_start;
    std::vector<size_t> herd_to_region_lookup;
    std::vector<real_type> p_region_export;
    std::vector<real_type> p_cow_export;
    std::vector<real_type> mean_herd_size;
    std::vector<real_type> movement_matrix;
    real_type start_count;
    size_t start_region;
  };

  struct internal_state {
    // population size per herd
    std::vector<real_type> N;
    std::vector<real_type> export_S;
    std::vector<real_type> export_E;
    std::vector<real_type> export_I;
    std::vector<real_type> export_R;
    std::vector<real_type> import_S;
    std::vector<real_type> import_E;
    std::vector<real_type> import_I;
    std::vector<real_type> import_R;
  };

  struct data_type {
    real_type incidence;
  };

  using rng_state_type = mcstate::random::generator<real_type>;

  static size_t size_state(const shared_state& shared) {
    return 4 * shared.n_herds;
  }

  static void initial(real_type time,
                      real_type dt,
                      const shared_state& shared,
                      internal_state& internal,
                      rng_state_type& rng_state,
                      real_type * state_next) {
    // Start by zeroing everything
    std::fill(state_next, state_next + size_state(shared), 0);
    // Then fill in susceptibles from the mean herd size
    //
    // Thom: should this be drawn from some distribution?  If so that
    // obviously causes a little grief with the seeding as we can't
    // absolutely guarantee that there enough cows to infect.
    auto *S = state_next;
    auto *I = state_next + shared.n_herds;
    for (size_t i = 0; i < shared.n_herds; ++i) {
      const auto j = shared.herd_to_region_lookup[i];
      S[i] = ceil(shared.mean_herd_size[j]);
    }
    // Seed the infections into the I class
    //
    // Thom: should this go into E rather than I?
    const auto i_start = shared.herd_to_region_lookup[shared.start_region];
    I[i_start] = shared.start_count;
    S[i_start] -= shared.start_count;
  }

  // The main update function, converting state to state_next
  static void update(real_type time,
                     real_type dt,
                     const real_type * state,
                     const shared_state& shared,
                     internal_state& internal,
                     rng_state_type& rng_state,
                     real_type * state_next) {
    const real_type* S = state;
    const real_type* E = state + shared.n_herds;
    const real_type* I = state + 2 * shared.n_herds;
    const real_type* R = state + 3 * shared.n_herds;

    real_type* S_next = state_next;
    real_type* E_next = state_next + shared.n_herds;
    real_type* I_next = state_next + 2 * shared.n_herds;
    real_type* R_next = state_next + 3 * shared.n_herds;

    for (size_t i = 0; i < shared.n_herds; ++i) {
      internal.N[i] = S[i] + E[i] + I[i] + R[i];
    }
    const real_type p_EI = 1 - std::exp(-shared.sigma * dt); // E to I
    const real_type p_IR = 1 - std::exp(-shared.gamma * dt); // I to R

    for (size_t i = 0; i < shared.n_regions; ++i) {
      const size_t i_start = shared.region_start[i];
      const size_t i_end = shared.region_start[i + 1];

      const real_type tot_I = std::accumulate(I + i_start, I + i_end, 0);
      const real_type tot_N = std::accumulate(internal.N.begin() + i_start, internal.N.begin() + i_end, 0);
      for (size_t j = i_start; j < i_end; ++j) {
        const real_type lambda = internal.N[j] == 0 ? 0 :
          (shared.beta * (I[j] / internal.N[j] + shared.alpha * (tot_I - I[j]) / (tot_N - internal.N[j])));
        const real_type p_SE = 1 - std::exp(-lambda * dt); // S to E
        const real_type n_SE = mcstate::random::binomial<real_type>(rng_state, S[j], p_SE);
        const real_type n_EI = mcstate::random::binomial<real_type>(rng_state, E[j], p_EI);
        const real_type n_IR = mcstate::random::binomial<real_type>(rng_state, I[j], p_IR);
        S_next[j] = S[j] - n_SE;
        E_next[j] = E[j] + n_SE - n_EI;
        I_next[j] = I[j] + n_EI - n_IR;
        R_next[j] = R[j] + n_IR;
      }
    }

    // Above, we change the populations (we do this BEFORE calculating import/exports)
    for (size_t i = 0; i < shared.n_herds; ++i) {
      const auto j = shared.herd_to_region_lookup[i];
      if (mcstate::random::random_real<real_type>(rng_state) < shared.p_region_export[j]) {
        internal.export_S[i] = mcstate::random::binomial<real_type>(rng_state, S_next[i], shared.p_cow_export[j]);
        internal.export_E[i] = mcstate::random::binomial<real_type>(rng_state, E_next[i], shared.p_cow_export[j]);
        internal.export_I[i] = mcstate::random::binomial<real_type>(rng_state, I_next[i], shared.p_cow_export[j]);
        internal.export_R[i] = mcstate::random::binomial<real_type>(rng_state, R_next[i], shared.p_cow_export[j]);
      }
    }

    const auto state_travel_allowed = time < shared.time_test;
    std::fill(internal.import_S.begin(), internal.import_S.end(), 0);
    std::fill(internal.import_E.begin(), internal.import_E.end(), 0);
    std::fill(internal.import_I.begin(), internal.import_I.end(), 0);
    std::fill(internal.import_R.begin(), internal.import_R.end(), 0);
    for (size_t i_src = 0; i_src < shared.n_herds; ++i_src) {
      const size_t export_N = internal.export_S[i_src] + internal.export_E[i_src] + internal.export_I[i_src] + internal.export_R[i_src];
      if (export_N > 0) {
        const size_t i_region_src = shared.herd_to_region_lookup[i_src];
        const auto p = shared.movement_matrix.begin() + i_region_src * shared.n_regions;
        const real_type u1 = mcstate::random::random_real<real_type>(rng_state);
        const size_t i_region_dst = std::binary_search(p, p + shared.n_regions, u1);
        const auto within_state = i_region_src == i_region_dst;
        const real_type u2 = mcstate::random::random_real<real_type>(rng_state);
        const size_t i_dst = shared.region_start[i_region_src] + std::floor(u2 * (shared.region_start[i_region_src + 1] - shared.region_start[i_region_src]));
        const bool allow_movement = within_state || state_travel_allowed ||
          mcstate::random::hypergeometric(rng_state, internal.export_I[i_src], export_N - internal.export_I[i_src], std::min(shared.n_test, internal.export_I[i_src])) == 0;
        if (allow_movement) {
          internal.import_S[i_dst] += internal.export_S[i_src];
          internal.import_E[i_dst] += internal.export_E[i_src];
          internal.import_I[i_dst] += internal.export_I[i_src];
          internal.import_R[i_dst] += internal.export_R[i_src];
        }
      }
    }
  }

  static shared_state build_shared(cpp11::list pars) {
    const size_t n_herds = dust2::r::read_size(pars, "n_herds");
    const size_t n_regions = dust2::r::read_size(pars, "n_regions");
    std::vector<size_t> region_start(n_regions + 1);
    auto r_region_start = pars["region_start"];
    const int * region_start_data = INTEGER(r_region_start);
    for (size_t i = 0; i < n_regions; ++i) {
      region_start[i] = region_start_data[i];
    }
    region_start[n_regions] = n_herds;

    std::vector<size_t> herd_to_region_lookup;
    herd_to_region_lookup.reserve(n_herds);
    for (size_t i = 0; i < n_regions; ++i) {
      for (size_t j = region_start[i]; j < region_start[i + 1]; ++j) {
        herd_to_region_lookup.push_back(i);
      }
    }

    if (herd_to_region_lookup.size() != n_herds) {
      cpp11::stop("Error while building lookup");
    }

    std::vector<real_type> p_region_export(n_regions);
    std::vector<real_type> p_cow_export(n_regions);
    std::vector<real_type> mean_herd_size(n_regions);
    dust2::r::read_real_vector(pars, n_regions, p_region_export.data(), "p_region_export", true);
    dust2::r::read_real_vector(pars, n_regions, p_cow_export.data(), "p_cow_export", true);
    dust2::r::read_real_vector(pars, n_regions, mean_herd_size.data(), "mean_herd_size", true);

    std::vector<real_type> movement_matrix(n_regions * n_regions);
    dust2::r::read_real_vector(pars, n_regions * n_regions, movement_matrix.data(), "movement_matrix", true);
    for (size_t i = 0; i < n_regions; ++i) {
      auto it = movement_matrix.begin();
      const real_type tot = std::accumulate(it + i * n_regions,
                                            it + (i + 1)* n_regions,
                                            0);
      for (size_t j = 0; j < n_regions; ++j) {
        if (j != 0) {
          *(it + j) += *(it + j - 1);
        }
        *(it + j) /= tot;
      }
    }

    const real_type time_test = dust2::r::read_real(pars, "time_test", 30);
    const real_type n_test = dust2::r::read_real(pars, "n_test", 30);

    const real_type start_count = dust2::r::read_real(pars, "start_count");
    const size_t start_region = dust2::r::read_size(pars, "start_region") - 1;

    const real_type beta = dust2::r::read_real(pars, "beta");
    const real_type gamma = dust2::r::read_real(pars, "gamma");
    const real_type alpha = dust2::r::read_real(pars, "alpha");
    const real_type sigma = dust2::r::read_real(pars, "sigma");

    return shared_state{n_herds, n_regions, gamma, sigma, beta, alpha, time_test, n_test, region_start, herd_to_region_lookup, p_region_export, p_cow_export, mean_herd_size, movement_matrix, start_count, start_region};
  }

  static internal_state build_internal(const shared_state& shared) {
    std::vector<real_type> N(shared.n_herds);
    std::vector<real_type> export_S(shared.n_herds);
    std::vector<real_type> export_E(shared.n_herds);
    std::vector<real_type> export_I(shared.n_herds);
    std::vector<real_type> export_R(shared.n_herds);
    std::vector<real_type> import_S(shared.n_herds);
    std::vector<real_type> import_E(shared.n_herds);
    std::vector<real_type> import_I(shared.n_herds);
    std::vector<real_type> import_R(shared.n_herds);
    return internal_state{N, export_S, export_E, export_I, export_R, import_S, import_E, import_I, import_R};
  }

  // This is the bit that we'll use to do fast parameter updating, and
  // we'll guarantee somewhere that the size does not change.
  static void update_shared(cpp11::list pars, shared_state& shared) {
    shared.beta = dust2::r::read_real(pars, "beta", shared.beta);
    shared.gamma = dust2::r::read_real(pars, "gamma", shared.gamma);
    shared.alpha = dust2::r::read_real(pars, "alpha", shared.alpha);
    shared.sigma = dust2::r::read_real(pars, "sigma", shared.sigma);
  }

  // This is a reasonable default implementation in the no-internal
  // case
  static void update_internal(const shared_state& shared,
                              internal_state& internal) {
  }

  static auto zero_every(const shared_state& shared) {
    return dust2::zero_every_type<real_type>();
  }
};

#include <cpp11.hpp>
#include <dust2/r/discrete/system.hpp>

[[cpp11::register]]
SEXP dust2_system_cows_alloc(cpp11::list r_pars, cpp11::sexp r_time, cpp11::sexp r_dt, cpp11::sexp r_n_particles, cpp11::sexp r_n_groups, cpp11::sexp r_seed, cpp11::sexp r_deterministic) {
  return dust2::r::dust2_discrete_alloc<cows>(r_pars, r_time, r_dt, r_n_particles, r_n_groups, r_seed, r_deterministic);
}
[[cpp11::register]]
SEXP dust2_system_cows_run_to_time(cpp11::sexp ptr, cpp11::sexp r_time) {
  return dust2::r::dust2_system_run_to_time<dust2::dust_discrete<cows>>(ptr, r_time);
}

[[cpp11::register]]
SEXP dust2_system_cows_state(cpp11::sexp ptr, bool grouped) {
  return dust2::r::dust2_system_state<dust2::dust_discrete<cows>>(ptr, grouped);
}

[[cpp11::register]]
SEXP dust2_system_cows_time(cpp11::sexp ptr) {
  return dust2::r::dust2_system_time<dust2::dust_discrete<cows>>(ptr);
}

[[cpp11::register]]
SEXP dust2_system_cows_set_state_initial(cpp11::sexp ptr) {
  return dust2::r::dust2_system_set_state_initial<dust2::dust_discrete<cows>>(ptr);
}

[[cpp11::register]]
SEXP dust2_system_cows_set_state(cpp11::sexp ptr, cpp11::sexp r_state, bool grouped) {
  return dust2::r::dust2_system_set_state<dust2::dust_discrete<cows>>(ptr, r_state, grouped);
}

[[cpp11::register]]
SEXP dust2_system_cows_reorder(cpp11::sexp ptr, cpp11::integers r_index) {
  return dust2::r::dust2_system_reorder<dust2::dust_discrete<cows>>(ptr, r_index);
}

[[cpp11::register]]
SEXP dust2_system_cows_rng_state(cpp11::sexp ptr) {
  return dust2::r::dust2_system_rng_state<dust2::dust_discrete<cows>>(ptr);
}

[[cpp11::register]]
SEXP dust2_system_cows_set_rng_state(cpp11::sexp ptr, cpp11::sexp r_rng_state) {
  return dust2::r::dust2_system_set_rng_state<dust2::dust_discrete<cows>>(ptr, r_rng_state);
}

[[cpp11::register]]
SEXP dust2_system_cows_set_time(cpp11::sexp ptr, cpp11::sexp r_time) {
  return dust2::r::dust2_system_set_time<dust2::dust_discrete<cows>>(ptr, r_time);
}

[[cpp11::register]]
SEXP dust2_system_cows_update_pars(cpp11::sexp ptr, cpp11::list pars, bool grouped) {
  return dust2::r::dust2_system_update_pars<dust2::dust_discrete<cows>>(ptr, pars, grouped);
}

[[cpp11::register]]
SEXP dust2_system_cows_simulate(cpp11::sexp ptr, cpp11::sexp r_times, cpp11::sexp r_index, bool grouped) {
  return dust2::r::dust2_system_simulate<dust2::dust_discrete<cows>>(ptr, r_times, r_index, grouped);
}
